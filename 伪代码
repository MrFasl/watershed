需要写的组件：
1.读入图片（opencv，矩阵形式）
2.彩色图像转为灰度值图像（函数1）
3.图像求梯度（函数2）
4.图像平滑（函数3）
5.像素点类：像素灰度值，归属的区域编号，是否为新一轮种子点，深度优先搜索（点，计数器），四邻域搜索（点）




具体步骤：
1.首先读入图像，转灰度值图像，平滑图像，尝试1用灰度值图像处理，2用梯度图像处理。
2.将图像的点放入像素点类型矩阵。
3.第一次注水，设置阈值，全局搜索低于阈值的点，将这些点（是否为新一轮种子点）属性设置为1，作为起始点。
4.初始化计数器为1，建立足够多个像素点类型数组，对上述标记的点赋区域编号，再进行深度优先搜索，即搜索四邻域，若被水
淹没就赋区域编号，再深度优先搜索该点。
/////////////////////////////步骤4
计数器=1；
for(i=0;i<n-1;i++)
{
      for(j=0;j<m-1;j++)
       {
          if(这点不是新一轮种子点)
                 continue；
          深度优先搜索（这一点，计数器）
          计数器++;
        }
}
再将全图的是否为新一轮种子点属性置为0.
//////////////////////////////
5.涨水（完成本步骤后全图所有点都应该被分入某一个区域内，且每个区域都是连续的）
for(水位不断上升)
{
         for(各个区域)
          {
           for(序号)
                    {
                     if（点空）break；
                     四邻域搜索该点；
                     }
           }
          搜索全图，若还存在可以被水淹没的&&没有区域标记的点，将他的是否为新一轮种子点属性置为1.
          这一步是为了为那些新的局域最小值建立新的水塘。
          for(i=0;i<n-1;i++)
     {
        for(j=0;j<m-1;j++)
         {
          if(这点不是新一轮种子点)
                 continue；
          深度优先搜索（这一点，计数器）
          计数器++;
         }
     }
     将全图的是否为新一轮种子点属性置为0.
}
6.建立一个新的矩阵，对于每个点根据其标记号赋值，再对该图求梯度，就能得到分界线。




function 深度优先搜索（点A，计数器C）
{
   if(已经有区域编号了)
   continue;
   A.区域编号=C
   把A加入C号像素点类型数组
   if(A.上被水淹没&&区域编号=0)
     深度优先搜索（A.上，C）
   if(A.下被水淹没&&区域编号=0)
     深度优先搜索（A.下，C）
   if(A.左被水淹没&&区域编号=0)
     深度优先搜索（A.左，C）
   if(A.右被水淹没&&区域编号=0)
     深度优先搜索（A.右，C）
}

function 四邻域搜索（点A，区域号C）
{
      if(A.上被水淹没&&区域编号=0)
       {
         A.上区域编号=C
         把A的上加入C号像素点类型数组
       }
      ……
}
